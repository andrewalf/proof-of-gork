# Task
Write TCP server with DDoS protection by Proof of Work algorithm. The Challenge-Response model must be used. The server must have a protected endpoint, returning a random quote. Also, write a client that solves the PoW challenge. Both server and client must be wrapped by Docker containers.

# Client stdout example
```
pow_client_1  | sending gimme request...
pow_client_1  | pow challenge: UVg42gMtUv-3-ae42df0422d745e55512c86f0c2e995e3c32cbc86e59036c5ba488b4c1f4b866
pow_client_1  | solution found: UVg42gMtUv-5089239-ae42df0422d745e55512c86f0c2e995e3c32cbc86e59036c5ba488b4c1f4b866
pow_client_1  | hash : 000�D]JKW���\Ev�m\�����R ����,�L�;�
pow_client_1  | time spent: 11.7048415s
pow_client_1  | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pow_client_1  | The world is round so that friendship may encircle it. (Pierre Teilhard de Chardin)
pow_client_1  | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

# How to launch

First two steps can be skipped if you have no problems with [step 3](https://github.com/docker/buildx/issues/476)
1. docker pull alpine:3.14
2. docker pull golang:1.16
3. cd /build && docker-compose up

# What was simplified
- client and server were written in a pretty simple manner
- no parallelization in solving challenges, that's useful there in multicore environment
- ports/hosts are hardcoded, of course, that's not an option in a real app
- tests don't cover all cases, I wrote them mostly for myself to check the correctness of the solution

# How it works

1. When a server receives `gimme` command it generates challenge - **find such x where hash(challenge_data + x)
contains N leading zeros**
2. Server generates mac, it's needed to verify that clint didn't change the  data
3. Server sends to client a challenge in form of: `nonce-N-mac`
4. Client finds a solution by iterating from 0 to uint32_MAX, by adding  the byte representation of a current integer to the nonce and calculating hash
5. When the solution is found client sends a request to the server: `gimme nonce-solution-mac`
6. Server calculates mac again using clients nonce and compares with clients mac, if they're same - the challenge was really generated by the server
7. Server calculates hash with nonce and received solution and validates if the resulted hash suits the challenges condition
8. If it's ok, the server returns a random quote string.

Server tries to close the TCP connection as soon as possible, so the client has to open a new connection for every request.
Receive a challenge - open connection. Send solution - open connection. That's obvious, otherwise what is the role of PoW if it's possible to spam
with "tcp-connection-opening" long-living requests that just hangs and does nothing and the server will be out of memory.

# There is one problem

At the design stage, I forgot about the protection from already used challenges. As a result, a challenge and its solution can be used in any amount of requests. I have no time to fix this because I already have to send the solution to HR.
How it's possible to be fixed: adding one more parameter - timestamp of the challenge generation time. The server has one more param too - TTL of the challenge. The timestamp must be used in mac generation process because it must be validated that it's not changed by the client **(server has no state and he sends all needed data to the client and expects it back)**
After receiving the solution and mac validating server ignores the request if *ts + TTL <= now*.
There's one more question: if the client is lucky and he managed to find the solution very quickly, he can use it N times while TTl is valid.
This can be fixed by storing a list of generated tasks on serverside and constantly refreshing this list by removing challenges that are out of TTL.
To improve memory usage we can use a bloom filter for this if the server is under a heavy load and there are tons of challenges generated

# Benchmarking

Just to be sure that finding a solution is much more time/CPU consuming than validating the challenge.

**L = nonce length, N - required amount of zeros**

## Finding solution

```
N = 1     L = 5      BenchmarkServerSolve_1_5-12           78872             17311 ns/op
N = 2     L = 10     BenchmarkServerSolve_2_10-12            100          24911305 ns/op
N = 2     L = 20     BenchmarkServerSolve_2_20-12            160          21156350 ns/op
N = 2     L = 50     BenchmarkServerSolve_2_50-12            373          65324338 ns/op
```

## Validating solution

```
N = 1     L = 5      BenchmarkServerValidate_1_5-12           1528162               791 ns/op
N = 2     L = 10     BenchmarkServerValidate_2_10-12          1554482               759 ns/op
N = 2     L = 20     BenchmarkServerValidate_2_20-12          1573590               762 ns/op
N = 2     L = 50     BenchmarkServerValidate_2_50-12          1321009               914 ns/op
```
